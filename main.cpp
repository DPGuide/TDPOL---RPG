// <--- SECTION: SYSTEM_HEADERS --->#include <windows.h>#include <mmsystem.h>#include <string>#include <map>#include <fstream>#include <vector>#pragma comment(lib,"winmm.lib")// <--- END SECTION --->typedef BOOL(WINAPI* T_pB)(HDC,int,int,int,int,HDC,int,int,int,int,UINT);T_pB pB = NULL;struct Hero {    bool active;    char name[32];    int x, y, rID, cID;    int sS, sD, sI, sW, sC;    int hp, hpMax;};struct Enemy {    int type, hp, hpMax, dmg;};struct Sprite {    HBITMAP hBmp;    int w, h;};enum GameState { S_INTRO, S_MENU, S_CHAR, S_CREATE, S_MAP, S_SETTINGS, S_CONTROLS, S_BATTLE };GameState state = S_INTRO;Hero heroes[10];Enemy curEnemy; // Der aktuelle Gegnerint curHeroIdx = 0, crRace = 0, crClass = 0, crStep = 0, menuIdx = 0, setIdx = 0, batIdx = 0;bool setMus = true, setSnd = true;std::string battleLog = "A WILD ENEMY APPEARS!"; // Kampf-Nachrichtstd::string nameInput = "HERO";std::map<int, Sprite> sprites;std::string RACES[5] = { "HUMAN", "ELF", "DARK ELF", "DWARF", "ORC" };std::string CLASSES[5] = { "WARRIOR", "MAGE", "ROGUE", "CLERIC", "BARD" };std::string BATTLE_CMD[4] = { "ATTACK", "MAGIC", "HEAL", "RUN" };void Save() {    std::ofstream o("save_v1475.dat", std::ios::binary);    if(o.is_open()) {        o.write((char*)heroes, sizeof(heroes));        o.close();    }}void Load() {    std::ifstream i("save_v1475.dat", std::ios::binary);    if(i.is_open()) {        i.read((char*)heroes, sizeof(heroes));        i.close();    }}void LoadSprite(int id, std::string path) {    HBITMAP h = (HBITMAP)LoadImageA(NULL, path.c_str(), IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);    if(h) {        BITMAP b;        GetObject(h, sizeof(BITMAP), &b);        sprites[id] = { h, b.bmWidth, b.bmHeight };    }}void DrawSpriteTrans(HDC hdc, int id, int x, int y) {    if(sprites.count(id)) {        Sprite& s = sprites[id];        HDC mdc = CreateCompatibleDC(hdc);        SelectObject(mdc, s.hBmp);        if(pB) pB(hdc, x, y, s.w, s.h, mdc, 0, 0, s.w, s.h, RGB(0,0,0));        DeleteDC(mdc);    }}void DrawBox(HDC hdc, int x, int y, int w, int h, std::string txt, COLORREF c, bool fill) {    HBRUSH b = CreateSolidBrush(fill ? RGB(100, 90, 80) : RGB(25, 25, 35));    HPEN p = CreatePen(PS_SOLID, 2, c);    SelectObject(hdc, b);    SelectObject(hdc, p);    Rectangle(hdc, x, y, x + w, y + h);    SetTextColor(hdc, c);    SetBkMode(hdc, 1);    TextOutA(hdc, x + 10, y + 12, txt.c_str(), (int)txt.length());    DeleteObject(b);    DeleteObject(p);}void initGame(HWND h) {    HMODULE hM = LoadLibraryA("msimg32.dll");    if(hM) pB = (T_pB)GetProcAddress(hM, "TransparentBlt");        mciSendStringA("close all", NULL, 0, 0);    mciSendStringA("open \"intro_01.wmv\" type MPEGVideo alias vid1 style popup", NULL, 0, 0);    mciSendStringA("play vid1 notify", NULL, 0, (HWND)h);    PlaySoundA("intro_music.wav", NULL, SND_ASYNC | SND_LOOP);    mciSendStringA("open \"intro_sound.wav\" type waveaudio alias snd1", NULL, 0, 0);	mciSendStringA("play snd1 notify", NULL, 0, (HWND)h);        Load();    LoadSprite(1, "pl_human.bmp");    LoadSprite(100, "map_1.bmp");    LoadSprite(101, "splash_title.bmp");    LoadSprite(20, "camp_human.bmp");    LoadSprite(21, "camp_elf.bmp");    LoadSprite(22, "camp_darkelf.bmp");    LoadSprite(23, "camp_dwarf.bmp");    LoadSprite(24, "camp_orc.bmp");        SetTimer(h, 1, 16, NULL);}void StartBattle() {    state = S_BATTLE;    curEnemy.type = 24; // ORC    curEnemy.hpMax = 50;    curEnemy.hp = 50;    curEnemy.dmg = 5;    battleLog = "A WILD ORC APPEARS!";}void HandleKeys(HWND h, WPARAM w) {    if(w == VK_ESCAPE) {        if(state == S_CONTROLS || state == S_BATTLE) state = S_SETTINGS;        else if(state == S_SETTINGS) state = S_MENU;        else if(state > S_MENU) state = S_MENU;        else {            mciSendStringA("close all", 0, 0, 0);            PostQuitMessage(0);        }    }        if(state == S_INTRO && (w == VK_SPACE || w == VK_RETURN)) {        mciSendStringA("close vid1", 0, 0, 0);        ShowWindow(h, SW_MAXIMIZE);        state = S_MENU;    }    else if(state == S_MENU) {        if(w == VK_UP) menuIdx = (menuIdx + 3) % 4;        if(w == VK_DOWN) menuIdx = (menuIdx + 1) % 4;        if(w == VK_RETURN) {            if(menuIdx < 2) state = S_CHAR;            else if(menuIdx == 2) state = S_SETTINGS;            else PostQuitMessage(0);        }    }    else if(state == S_SETTINGS) {        if(w == VK_UP) setIdx = (setIdx + 3) % 4;        if(w == VK_DOWN) setIdx = (setIdx + 1) % 4;        if(w == VK_RETURN) {            if(setIdx == 0) {                setMus = !setMus;                if(setMus) PlaySoundA("intro_music.wav", NULL, SND_ASYNC | SND_LOOP);                else PlaySoundA(NULL, 0, 0);            }            if(setIdx == 1) setSnd = !setSnd;            if(setIdx == 2) state = S_CONTROLS;            if(setIdx == 3) state = S_MENU;        }    }    else if(state == S_CHAR) {        if(w == VK_UP) curHeroIdx = (curHeroIdx + 9) % 10;        if(w == VK_DOWN) curHeroIdx = (curHeroIdx + 1) % 10;        if(w == VK_RETURN) {            if(heroes[curHeroIdx].active) state = S_MAP;            else {                state = S_CREATE;                crStep = 0;                nameInput = "";            }        }    }    else if(state == S_CREATE) {        if(crStep == 0) {            if(w == VK_UP) crRace = (crRace + 4) % 5;            if(w == VK_DOWN) crRace = (crRace + 1) % 5;            if(w == VK_RETURN) crStep = 1;        }        else if(crStep == 1) {            if(w == VK_UP) crClass = (crClass + 4) % 5;            if(w == VK_DOWN) crClass = (crClass + 1) % 5;            if(w == VK_RETURN) crStep = 2;            if(w == VK_BACK) crStep = 0;        }        else if(crStep == 2) {            if(w == VK_BACK && nameInput.length() > 0) nameInput.pop_back();            else if(w >= 32 && w <= 126 && nameInput.length() < 15) nameInput += (char)w;            if(w == VK_RETURN && nameInput.length() > 0) {                Hero& he = heroes[curHeroIdx];                he.active = true;                he.x = 7;                he.y = 7;                he.rID = crRace;                he.cID = crClass;                strcpy(he.name, nameInput.c_str());                he.sS = 10+crRace+(crClass == 0?5:0);                he.sD = 10+(crClass == 2?5:0);                he.sI = 10+(crClass == 1?5:0);                he.sW = 10+(crClass == 3?5:0);                he.sC = 10+(crRace == 4?3:0);                he.hp = he.sC * 10;                he.hpMax = he.hp;                Save();                state = S_MAP;            }        }    }    else if(state == S_BATTLE) {        if(w == VK_LEFT) batIdx = (batIdx + 3) % 4;        if(w == VK_RIGHT) batIdx = (batIdx + 1) % 4;        if(w == VK_RETURN) {            Hero& h = heroes[curHeroIdx];            if(batIdx == 0) { // ATTACK                int dmg = (h.sS * 3) / 2;                curEnemy.hp -= dmg;                battleLog = "HIT FOR " + std::to_string(dmg) + " DMG!";                if(curEnemy.hp <= 0) {                    battleLog = "VICTORY!";                    state = S_MAP;                }            }            if(batIdx == 2) { // HEAL                h.hp += h.sW * 2;                if(h.hp > h.hpMax) h.hp = h.hpMax;                battleLog = "HEALED!";            }            if(batIdx == 3) { // RUN                if(h.sD > 10) {                    battleLog = "ESCAPED!";                    state = S_MAP;                }                else battleLog = "FAILED TO RUN!";            }        }    }    else if(state == S_MAP) {        Hero& p = heroes[curHeroIdx];        if(w == VK_LEFT) p.x -= 1;        if(w == VK_RIGHT) p.x += 1;        if(w == VK_UP) p.y -= 1;        if(w == VK_DOWN) p.y += 1;        // BATTLE TRIGGER (TEST KEY 'B')        if(w == 'B') StartBattle();    }}LRESULT CALLBACK GameProc(HWND h, UINT m, WPARAM w, LPARAM l) {    if(m == WM_DESTROY) {        mciSendStringA("close all", 0, 0, 0);        PostQuitMessage(0);        return 0;    }    if(m == WM_KEYDOWN) HandleKeys(h, w);    if(m == WM_TIMER) InvalidateRect(h, NULL, false);    if(m == MM_MCINOTIFY && state == S_INTRO && w == MCI_NOTIFY_SUCCESSFUL) {        mciSendStringA("close vid1", 0, 0, 0);        ShowWindow(h, SW_MAXIMIZE);        state = S_MENU;    }    if(m == WM_PAINT) {        PAINTSTRUCT ps;        HDC hdc = BeginPaint(h, &ps);        if(state == S_INTRO) {            EndPaint(h, &ps);            return 0;        }        RECT r;        GetClientRect(h, &r);        if(r.right < 10) {            EndPaint(h, &ps);            return 0;        }        HDC mdc = CreateCompatibleDC(hdc);        HBITMAP mb = CreateCompatibleBitmap(hdc, r.right, r.bottom);        SelectObject(mdc, mb);                HBRUSH bg = CreateSolidBrush(RGB(10, 15, 30));        FillRect(mdc, &r, bg);        DeleteObject(bg);                HFONT f = CreateFontA(24,0,0,0,700,0,0,0,0,0,0,0,0,"Arial");        SelectObject(mdc, f);        SetTextColor(mdc, RGB(255, 215, 0));        SetBkMode(mdc, 1);                if(state == S_MENU) {            if(sprites.count(101)) {                HDC sdc = CreateCompatibleDC(mdc);                SelectObject(sdc, sprites[101].hBmp);                StretchBlt(mdc,0,0,r.right,r.bottom,sdc,0,0,sprites[101].w,sprites[101].h,SRCCOPY);                DeleteDC(sdc);            }            std::string b[4] = {"PLAY", "NEW", "SETTINGS", "EXIT"};            for(int i=0; i<4; i++) DrawBox(mdc, r.right/2-100, r.bottom/2-100+(i*65), 200, 50, b[i], RGB(255,215,0), menuIdx == i);        }        else if(state == S_SETTINGS) {            std::string s[4] = {"MUSIC: " + std::string(setMus?"ON":"OFF"), "SOUND: " + std::string(setSnd?"ON":"OFF"), "CONTROLS", "BACK"};            for(int i=0; i<4; i++) DrawBox(mdc, 100, 150+(i*60), 300, 50, s[i], RGB(255,215,0), setIdx == i);        }        else if(state == S_CONTROLS) {            TextOutA(mdc, 100, 100, "ARROWS = MOVE", 13);            TextOutA(mdc, 100, 150, "ENTER = SELECT", 14);            TextOutA(mdc, 100, 200, "ESC = BACK", 10);        }        else if(state == S_CHAR) {            TextOutA(mdc, 50, 50, "SELECT HERO", 11);            for(int i=0; i<10; i++) DrawBox(mdc, 50, 100+(i*55), 350, 45, heroes[i].active ? heroes[i].name : "[ EMPTY SLOT ]", RGB(255,215,0), curHeroIdx == i);        }        else if(state == S_CREATE) {            for(int i=0; i<5; i++) DrawBox(mdc, 50, 100+(i*55), 180, 45, RACES[i], RGB(255,215,0), (crRace == i && crStep == 0) || (crStep > 0 && crRace == i));            for(int i=0; i<5; i++) DrawBox(mdc, 240, 100+(i*55), 180, 45, CLASSES[i], RGB(255,215,0), (crClass == i && crStep == 1) || (crStep > 1 && crClass == i));            if(sprites.count(20+crRace)) {                Sprite& s = sprites[20+crRace];                DrawSpriteTrans(mdc, 20+crRace, (r.right-s.w)/2, (r.bottom-s.h)/2);            }            int sS = 10+crRace+(crClass == 0?5:0);            std::string sT = "STR: " + std::to_string(sS);            TextOutA(mdc, r.right-250, 150, sT.c_str(), (int)sT.length());                        int sD = 10+(crClass == 2?5:0);            std::string sD_t = "DEX: " + std::to_string(sD);            TextOutA(mdc, r.right-250, 200, sD_t.c_str(), (int)sD_t.length());                        int sI = 10+(crClass == 1?5:0);            std::string sI_t = "INT: " + std::to_string(sI);            TextOutA(mdc, r.right-250, 250, sI_t.c_str(), (int)sI_t.length());                        int sW = 10+(crClass == 3?5:0);            std::string sW_t = "WIS: " + std::to_string(sW);            TextOutA(mdc, r.right-250, 300, sW_t.c_str(), (int)sW_t.length());                        int sC = 10+(crRace == 4?3:0);            std::string sC_t = "CON: " + std::to_string(sC);            TextOutA(mdc, r.right-250, 350, sC_t.c_str(), (int)sC_t.length());                        DrawBox(mdc, r.right/2-150, 40, 300, 50, "NAME: " + nameInput + (crStep == 2 ? "_":""), RGB(255,215,0), crStep == 2);        }        else if(state == S_BATTLE) {            TextOutA(mdc, r.right/2 - 100, 50, battleLog.c_str(), (int)battleLog.length());            for(int i=0; i<4; i++) DrawBox(mdc, r.right/2 - 320 + (i*160), r.bottom - 100, 150, 50, BATTLE_CMD[i], RGB(255,215,0), batIdx == i);            DrawSpriteTrans(mdc, curEnemy.type, (r.right-100)/2, r.bottom/2 - 100);                        std::string eHP = "ENEMY HP: " + std::to_string(curEnemy.hp);            TextOutA(mdc, r.right/2 - 50, r.bottom/2 + 50, eHP.c_str(), (int)eHP.length());                        std::string hHP = "HERO HP: " + std::to_string(heroes[curHeroIdx].hp);            TextOutA(mdc, 50, r.bottom - 50, hHP.c_str(), (int)hHP.length());        }        else if(state == S_MAP) {            if(sprites.count(100)) {                HDC sdc = CreateCompatibleDC(mdc);                SelectObject(sdc, sprites[100].hBmp);                StretchBlt(mdc,0,0,r.right,r.bottom,sdc,0,0,sprites[100].w,sprites[100].h,SRCCOPY);                DeleteDC(sdc);            }            int tSz = r.bottom/15;            DrawSpriteTrans(mdc, 1, (r.right-tSz*15)/2 + heroes[curHeroIdx].x*tSz, heroes[curHeroIdx].y*tSz);        }                BitBlt(hdc, 0, 0, r.right, r.bottom, mdc, 0, 0, SRCCOPY);        DeleteObject(mb);        DeleteDC(mdc);        DeleteObject(f);        EndPaint(h, &ps);    }    return DefWindowProcA(h, m, w, l);}int WINAPI WinMain(HINSTANCE i, HINSTANCE p, LPSTR c, int s) {    WNDCLASSA wc = {0};    wc.lpfnWndProc = GameProc;    wc.hInstance = i;    wc.lpszClassName = "RPG";    RegisterClassA(&wc);        HWND h = CreateWindowA("RPG", "Dark Path to Light", WS_OVERLAPPEDWINDOW | WS_VISIBLE | WS_MAXIMIZE, 0, 0, 1280, 720, NULL, NULL, i, NULL);        initGame(h);    MSG msg;    while(GetMessageA(&msg, NULL, 0, 0)) {        TranslateMessage(&msg);        DispatchMessageA(&msg);    }    return 0;}